
==============================================================
          DB25 SQL Parser - Enhanced AST Viewer v2.0
==============================================================

Loaded 39 queries from tests/showcase_queries.sqls

=== Query #1 ===
SQL: SELECT * FROM users

Parse Statistics:
  Parse Time:         10 us
  Node Count:          5 nodes
  Tree Depth:          3 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
SELECT LIST
*
FROM
TABLE: users
--------------------------------------------------

------------------------------------------------------------

=== Query #2 ===
SQL: SELECT id, name, email FROM customers

Parse Statistics:
  Parse Time:          5 us
  Node Count:          7 nodes
  Tree Depth:          3 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
SELECT LIST
COLUMN: id
COLUMN: name
COLUMN: email
FROM
TABLE: customers
--------------------------------------------------

------------------------------------------------------------

=== Query #3 ===
SQL: SELECT * FROM products WHERE price > 100 AND stock > 0

Parse Statistics:
  Parse Time:          2 us
  Node Count:         13 nodes
  Tree Depth:          5 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
SELECT LIST
*
FROM
TABLE: products
WHERE
BINARY [AND]
BINARY [>]
COLUMN: price
INT: 100
BINARY [>]
COLUMN: stock
INT: 0
--------------------------------------------------

------------------------------------------------------------

=== Query #4 ===
SQL: SELECT name, score FROM students ORDER BY score DESC LIMIT 10

Parse Statistics:
  Parse Time:          2 us
  Node Count:         10 nodes
  Tree Depth:          3 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
SELECT LIST
COLUMN: name
COLUMN: score
FROM
TABLE: students
ORDER BY
COLUMN: score
LIMIT
INT: 10
--------------------------------------------------

------------------------------------------------------------

=== Query #5 ===
SQL: SELECT u.name, o.total  FROM users u  INNER JOIN orders o ON u.id = o.user_id

Parse Statistics:
  Parse Time:          4 us
  Node Count:         11 nodes
  Tree Depth:          5 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
SELECT LIST
COLUMN: u.name
COLUMN: o.total
FROM
TABLE: users (schema: u)
JOIN: INNER JOIN
TABLE: orders (schema: o)
BINARY [=]
COLUMN: u.id
COLUMN: o.user_id
--------------------------------------------------

------------------------------------------------------------

=== Query #6 ===
SQL: SELECT c.name, o.order_date, p.product_name, oi.quantity FROM customers c JOIN orders o ON c.id = o.customer_id JOIN order_items oi ON o.id = oi.order_id JOIN products p ON oi.product_id = p.id WHERE o.order_date >= '2024-01-01'

Parse Statistics:
  Parse Time:          6 us
  Node Count:         27 nodes
  Tree Depth:          5 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
SELECT LIST
COLUMN: c.name
COLUMN: o.order_date
COLUMN: p.product_name
COLUMN: oi.quantity
FROM
TABLE: customers (schema: c)
JOIN: JOIN
TABLE: orders (schema: o)
BINARY [=]
COLUMN: c.id
COLUMN: o.customer_id
JOIN: JOIN
TABLE: order_items (schema: oi)
BINARY [=]
COLUMN: o.id
COLUMN: oi.order_id
JOIN: JOIN
TABLE: products (schema: p)
BINARY [=]
COLUMN: oi.product_id
COLUMN: p.id
WHERE
BINARY [>=]
COLUMN: o.order_date
STRING: ''2024-01-01''
--------------------------------------------------

------------------------------------------------------------

=== Query #7 ===
SQL: SELECT d.name, COUNT(e.id) as emp_count FROM departments d LEFT JOIN employees e ON d.id = e.dept_id GROUP BY d.id, d.name HAVING COUNT(e.id) > 5

Parse Statistics:
  Parse Time:          5 us
  Node Count:         20 nodes
  Tree Depth:          5 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
SELECT LIST
COLUMN: d.name
FUNCTION: COUNT (schema: emp_count)
COLUMN: e.id
FROM
TABLE: departments (schema: d)
JOIN: LEFT JOIN
TABLE: employees (schema: e)
BINARY [=]
COLUMN: d.id
COLUMN: e.dept_id
GROUP BY
COLUMN: d.id
COLUMN: d.name
HAVING
BINARY [>]
FUNCTION: COUNT
COLUMN: e.id
INT: 5
--------------------------------------------------

------------------------------------------------------------

=== Query #8 ===
SQL: SELECT COUNT(*) as total, AVG(price) as avg_price FROM products

Parse Statistics:
  Parse Time:          3 us
  Node Count:          8 nodes
  Tree Depth:          4 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
SELECT LIST
FUNCTION: COUNT (schema: total)
*
FUNCTION: AVG (schema: avg_price)
IDENTIFIER: price
FROM
TABLE: products
--------------------------------------------------

------------------------------------------------------------

=== Query #9 ===
SQL: SELECT category, COUNT(*) as count, MAX(price) as max_price FROM products GROUP BY category HAVING COUNT(*) > 10

Parse Statistics:
  Parse Time:          3 us
  Node Count:         16 nodes
  Tree Depth:          5 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
SELECT LIST
COLUMN: category
FUNCTION: COUNT (schema: count)
*
FUNCTION: MAX (schema: max_price)
IDENTIFIER: price
FROM
TABLE: products
GROUP BY
COLUMN: category
HAVING
BINARY [>]
FUNCTION: COUNT
*
INT: 10
--------------------------------------------------

------------------------------------------------------------

=== Query #10 ===
SQL: SELECT dept, job_title, COUNT(*) as count FROM employees GROUP BY GROUPING SETS ((dept), (job_title), (dept, job_title), ())

Parse Statistics:
  Parse Time:          3 us
  Node Count:         18 nodes
  Tree Depth:          5 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
SELECT LIST
COLUMN: dept
COLUMN: job_title
FUNCTION: COUNT (schema: count)
*
FROM
TABLE: employees
GROUP BY
NODE_70: GROUPING_SETS
NODE_96
COLUMN: dept
NODE_96
COLUMN: job_title
NODE_96
COLUMN: dept
COLUMN: job_title
NODE_96
--------------------------------------------------

------------------------------------------------------------

=== Query #11 ===
SQL: SELECT      name,     department,     salary,     RANK() OVER (PARTITION BY department ORDER BY salary DESC) as dept_rank FROM employees

Parse Statistics:
  Parse Time:          3 us
  Node Count:         13 nodes
  Tree Depth:          6 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
SELECT LIST
COLUMN: name
COLUMN: department
COLUMN: salary
FUNCTION: RANK (schema: dept_rank)
WINDOW
NODE_100
COLUMN: department
ORDER BY
COLUMN: salary
FROM
TABLE: employees
--------------------------------------------------

------------------------------------------------------------

=== Query #12 ===
SQL: SELECT      order_date,     amount,     SUM(amount) OVER (ORDER BY order_date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as running_total FROM orders

Parse Statistics:
  Parse Time:          3 us
  Node Count:         14 nodes
  Tree Depth:          6 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
SELECT LIST
COLUMN: order_date
COLUMN: amount
FUNCTION: SUM (schema: running_total)
IDENTIFIER: amount
WINDOW
ORDER BY
COLUMN: order_date
NODE_102: ROWS
NODE_103: UNBOUNDED (schema: PRECEDING)
NODE_103: CURRENT ROW
FROM
TABLE: orders
--------------------------------------------------

------------------------------------------------------------

=== Query #13 ===
SQL: SELECT      name,     score,     RANK() OVER (ORDER BY score DESC) as rank,     DENSE_RANK() OVER (ORDER BY score DESC) as dense_rank,     NTILE(4) OVER (ORDER BY score DESC) as quartile FROM students

Parse Statistics:
  Parse Time:          4 us
  Node Count:         19 nodes
  Tree Depth:          6 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
SELECT LIST
COLUMN: name
COLUMN: score
FUNCTION: RANK (schema: rank)
WINDOW
ORDER BY
COLUMN: score
FUNCTION: DENSE_RANK (schema: dense_rank)
WINDOW
ORDER BY
COLUMN: score
FUNCTION: NTILE (schema: quartile)
INT: 4
WINDOW
ORDER BY
COLUMN: score
FROM
TABLE: students
--------------------------------------------------

------------------------------------------------------------

=== Query #14 ===
SQL: WITH high_value_customers AS (     SELECT customer_id, SUM(total) as total_spent     FROM orders     GROUP BY customer_id     HAVING SUM(total) > 10000 ) SELECT c.name, h.total_spent FROM customers c JOIN high_value_customers h ON c.id = h.customer_id

Parse Statistics:
  Parse Time:          5 us
  Node Count:         27 nodes
  Tree Depth:          8 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
NODE_94
CTE: high_value_customers
SELECT
SELECT LIST
COLUMN: customer_id
FUNCTION: SUM (schema: total_spent)
IDENTIFIER: total
FROM
TABLE: orders
GROUP BY
COLUMN: customer_id
HAVING
BINARY [>]
FUNCTION: SUM
IDENTIFIER: total
INT: 10000
SELECT LIST
COLUMN: c.name
COLUMN: h.total_spent
FROM
TABLE: customers (schema: c)
JOIN: JOIN
TABLE: high_value_customers (schema: h)
BINARY [=]
COLUMN: c.id
COLUMN: h.customer_id
--------------------------------------------------

------------------------------------------------------------

=== Query #15 ===
SQL: WITH RECURSIVE employee_hierarchy AS (     SELECT id, name, manager_id, 0 as level     FROM employees     WHERE manager_id IS NULL     UNION ALL     SELECT e.id, e.name, e.manager_id, h.level + 1     FROM employees e     JOIN employee_hierarchy h ON e.manager_id = h.id ) SELECT * FROM employee_hierarchy ORDER BY level, name

Parse Statistics:
  Parse Time:          6 us
  Node Count:         37 nodes
  Tree Depth:          9 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
NODE_94
CTE: employee_hierarchy
UNION: UNION
SELECT
SELECT LIST
COLUMN: id
COLUMN: name
COLUMN: manager_id
INT: 0 (schema: level)
FROM
TABLE: employees
WHERE
IS NULL: IS NULL
COLUMN: manager_id
SELECT
SELECT LIST
COLUMN: e.id
COLUMN: e.name
COLUMN: e.manager_id
BINARY [+]
COLUMN: h.level
INT: 1
FROM
TABLE: employees (schema: e)
JOIN: JOIN
TABLE: employee_hierarchy (schema: h)
BINARY [=]
COLUMN: e.manager_id
COLUMN: h.id
SELECT LIST
*
FROM
TABLE: employee_hierarchy
ORDER BY
COLUMN: level
COLUMN: name
--------------------------------------------------

------------------------------------------------------------

=== Query #16 ===
SQL: WITH  sales_by_month AS (     SELECT          DATE_TRUNC('month', order_date) as month,         SUM(total) as monthly_total     FROM orders     GROUP BY DATE_TRUNC('month', order_date) ), avg_sales AS (     SELECT AVG(monthly_total) as avg_monthly     FROM sales_by_month ) SELECT      s.month,     s.monthly_total,     a.avg_monthly,     s.monthly_total - a.avg_monthly as variance FROM sales_by_month s CROSS JOIN avg_sales a

Parse Statistics:
  Parse Time:          6 us
  Node Count:         34 nodes
  Tree Depth:          7 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
NODE_94
CTE: sales_by_month
SELECT
SELECT LIST
FUNCTION: DATE_TRUNC (schema: month)
STRING: ''month''
IDENTIFIER: order_date
FUNCTION: SUM (schema: monthly_total)
IDENTIFIER: total
FROM
TABLE: orders
GROUP BY
FUNCTION: DATE_TRUNC
STRING: ''month''
IDENTIFIER: order_date
CTE: avg_sales
SELECT
SELECT LIST
FUNCTION: AVG (schema: avg_monthly)
IDENTIFIER: monthly_total
FROM
TABLE: sales_by_month
SELECT LIST
COLUMN: s.month
COLUMN: s.monthly_total
COLUMN: a.avg_monthly
BINARY [-] (schema: variance)
COLUMN: s.monthly_total
COLUMN: a.avg_monthly
FROM
TABLE: sales_by_month (schema: s)
JOIN: CROSS JOIN
TABLE: avg_sales (schema: a)
--------------------------------------------------

------------------------------------------------------------

=== Query #17 ===
SQL: SELECT      name,     salary,     (SELECT AVG(salary) FROM employees) as avg_salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees)

Parse Statistics:
  Parse Time:          3 us
  Node Count:         23 nodes
  Tree Depth:          8 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
SELECT LIST
COLUMN: name
COLUMN: salary
NODE_93 (schema: avg_salary)
SELECT
SELECT LIST
FUNCTION: AVG
IDENTIFIER: salary
FROM
TABLE: employees
FROM
TABLE: employees
WHERE
BINARY [>]
COLUMN: salary
NODE_93
SELECT
SELECT LIST
FUNCTION: AVG
IDENTIFIER: salary
FROM
TABLE: employees
--------------------------------------------------

------------------------------------------------------------

=== Query #18 ===
SQL: SELECT * FROM products WHERE category_id IN (     SELECT id FROM categories WHERE name LIKE '%Electronics%' )

Parse Statistics:
  Parse Time:          2 us
  Node Count:         18 nodes
  Tree Depth:          8 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
SELECT LIST
*
FROM
TABLE: products
WHERE
IN: IN
COLUMN: category_id
NODE_93
SELECT
SELECT LIST
COLUMN: id
FROM
TABLE: categories
WHERE
LIKE: LIKE
COLUMN: name
STRING: ''%Electronics%''
--------------------------------------------------

------------------------------------------------------------

=== Query #19 ===
SQL: SELECT c.* FROM customers c WHERE EXISTS (     SELECT 1 FROM orders o     WHERE o.customer_id = c.id     AND o.order_date >= CURRENT_DATE - INTERVAL '30 days' )

Parse Statistics:
  Parse Time:          2 us
  Node Count:          5 nodes
  Tree Depth:          4 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
SELECT LIST
BINARY [*] (schema: customers)
COLUMN: c
COLUMN: FROM
--------------------------------------------------

------------------------------------------------------------

=== Query #20 ===
SQL: SELECT      e1.name,     e1.salary,     (SELECT COUNT(*) FROM employees e2       WHERE e2.department = e1.department       AND e2.salary > e1.salary) as higher_paid_in_dept FROM employees e1

Parse Statistics:
  Parse Time:          4 us
  Node Count:         21 nodes
  Tree Depth:          8 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
SELECT LIST
COLUMN: e1.name
COLUMN: e1.salary
NODE_93 (schema: higher_paid_in_dept)
SELECT
SELECT LIST
FUNCTION: COUNT
*
FROM
TABLE: employees (schema: e2)
WHERE
BINARY [AND]
BINARY [=]
COLUMN: e2.department
COLUMN: e1.department
BINARY [>]
COLUMN: e2.salary
COLUMN: e1.salary
FROM
TABLE: employees (schema: e1)
--------------------------------------------------

------------------------------------------------------------

=== Query #21 ===
SQL: SELECT      name,     CASE status         WHEN 'active' THEN 'Active User'         WHEN 'inactive' THEN 'Inactive User'         WHEN 'suspended' THEN 'Account Suspended'         ELSE 'Unknown Status'     END as status_label FROM users

Parse Statistics:
  Parse Time:          2 us
  Node Count:         17 nodes
  Tree Depth:          5 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
SELECT LIST
COLUMN: name
CASE (schema: status_label)
IDENTIFIER: status
BINARY [WHEN]
STRING: ''active''
STRING: ''Active User''
BINARY [WHEN]
STRING: ''inactive''
STRING: ''Inactive User''
BINARY [WHEN]
STRING: ''suspended''
STRING: ''Account Suspended''
STRING: ''Unknown Status''
FROM
TABLE: users
--------------------------------------------------

------------------------------------------------------------

=== Query #22 ===
SQL: SELECT      product_name,     price,     CASE          WHEN price < 10 THEN 'Budget'         WHEN price BETWEEN 10 AND 50 THEN 'Standard'         WHEN price BETWEEN 50 AND 100 THEN 'Premium'         WHEN price > 100 THEN 'Luxury'         ELSE 'Unpriced'     END as price_category FROM products

Parse Statistics:
  Parse Time:          4 us
  Node Count:         30 nodes
  Tree Depth:          6 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
SELECT LIST
COLUMN: product_name
COLUMN: price
CASE (schema: price_category)
BINARY [WHEN]
BINARY [<]
IDENTIFIER: price
INT: 10
STRING: ''Budget''
BINARY [WHEN]
BETWEEN: BETWEEN
IDENTIFIER: price
INT: 10
INT: 50
STRING: ''Standard''
BINARY [WHEN]
BETWEEN: BETWEEN
IDENTIFIER: price
INT: 50
INT: 100
STRING: ''Premium''
BINARY [WHEN]
BINARY [>]
IDENTIFIER: price
INT: 100
STRING: ''Luxury''
STRING: ''Unpriced''
FROM
TABLE: products
--------------------------------------------------

------------------------------------------------------------

=== Query #23 ===
SQL: INSERT INTO users (name, email, created_at)  VALUES ('John Doe', 'john@example.com', NOW())

Parse Statistics:
  Parse Time:          2 us
  Node Count:          2 nodes
  Tree Depth:          2 levels

Abstract Syntax Tree:
--------------------------------------------------
INSERT
TABLE: users
--------------------------------------------------

------------------------------------------------------------

=== Query #24 ===
SQL: INSERT INTO archived_orders  SELECT * FROM orders  WHERE order_date < '2023-01-01'

Parse Statistics:
  Parse Time:          1 us
  Node Count:         11 nodes
  Tree Depth:          5 levels

Abstract Syntax Tree:
--------------------------------------------------
INSERT
TABLE: archived_orders
SELECT
SELECT LIST
*
FROM
TABLE: orders
WHERE
BINARY [<]
COLUMN: order_date
STRING: ''2023-01-01''
--------------------------------------------------

------------------------------------------------------------

=== Query #25 ===
SQL: UPDATE products  SET price = price * 1.1,      updated_at = NOW()  WHERE category = 'Electronics' AND stock > 0

Parse Statistics:
  Parse Time:          2 us
  Node Count:         11 nodes
  Tree Depth:          5 levels

Abstract Syntax Tree:
--------------------------------------------------
UPDATE
TABLE: products
SET
BINARY [price]
BINARY [*]
IDENTIFIER: price
INT: 1.1
BINARY [updated_at]
FUNCTION: NOW
WHERE
COLUMN: WHERE
--------------------------------------------------

------------------------------------------------------------

=== Query #26 ===
SQL: DELETE FROM sessions  WHERE last_activity < CURRENT_TIMESTAMP - INTERVAL '24 hours'

Parse Statistics:
  Parse Time:          1 us
  Node Count:          4 nodes
  Tree Depth:          3 levels

Abstract Syntax Tree:
--------------------------------------------------
DELETE
TABLE: sessions
WHERE
COLUMN: WHERE
--------------------------------------------------

------------------------------------------------------------

=== Query #27 ===
SQL: CREATE TABLE customers (     id SERIAL PRIMARY KEY,     name VARCHAR(100) NOT NULL,     email VARCHAR(255) UNIQUE NOT NULL,     phone VARCHAR(20),     address TEXT,     created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,     updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP )

Parse Statistics:
  Parse Time:          4 us
  Node Count:          1 nodes
  Tree Depth:          1 levels

Abstract Syntax Tree:
--------------------------------------------------
CREATE TABLE: customers
--------------------------------------------------

------------------------------------------------------------

=== Query #28 ===
SQL: CREATE TABLE orders (     id BIGSERIAL PRIMARY KEY,     customer_id INTEGER NOT NULL REFERENCES customers(id) ON DELETE CASCADE,     order_date DATE NOT NULL DEFAULT CURRENT_DATE,     total DECIMAL(10, 2) NOT NULL CHECK (total >= 0),     status VARCHAR(20) DEFAULT 'pending',     CONSTRAINT valid_status CHECK (status IN ('pending', 'processing', 'shipped', 'delivered', 'cancelled')) )

Parse Statistics:
  Parse Time:          5 us
  Node Count:          1 nodes
  Tree Depth:          1 levels

Abstract Syntax Tree:
--------------------------------------------------
CREATE TABLE: orders
--------------------------------------------------

------------------------------------------------------------

=== Query #29 ===
SQL: CREATE INDEX idx_orders_customer_date  ON orders(customer_id, order_date DESC)

Parse Statistics:
  Parse Time:          1 us
  Node Count:          1 nodes
  Tree Depth:          1 levels

Abstract Syntax Tree:
--------------------------------------------------
CREATE INDEX: idx_orders_customer_date (schema: orders)
--------------------------------------------------

------------------------------------------------------------

=== Query #30 ===
SQL: CREATE VIEW active_customers AS SELECT c.*, COUNT(o.id) as order_count FROM customers c LEFT JOIN orders o ON c.id = o.customer_id WHERE c.created_at >= CURRENT_DATE - INTERVAL '1 year' GROUP BY c.id

Parse Statistics:
  Parse Time:          4 us
  Node Count:         19 nodes
  Tree Depth:          6 levels

Abstract Syntax Tree:
--------------------------------------------------
CREATE VIEW: active_customers
SELECT
SELECT LIST
COLUMN: c
FUNCTION: COUNT (schema: order_count)
COLUMN: o.id
FROM
TABLE: customers (schema: c)
JOIN: LEFT JOIN
TABLE: orders (schema: o)
BINARY [=]
COLUMN: c.id
COLUMN: o.customer_id
WHERE
BINARY [>=]
COLUMN: c.created_at
BINARY [-]
COLUMN: CURRENT_DATE
COLUMN: INTERVAL
--------------------------------------------------

------------------------------------------------------------

=== Query #31 ===
SQL: ALTER TABLE products  ADD COLUMN discount_percentage DECIMAL(5, 2) DEFAULT 0 CHECK (discount_percentage >= 0 AND discount_percentage <= 100)

Parse Statistics:
  Parse Time:          3 us
  Node Count:         14 nodes
  Tree Depth:          7 levels

Abstract Syntax Tree:
--------------------------------------------------
ALTER TABLE: products
NODE_43: ADD
COLUMN_DEF: discount_percentage
DATA_TYPE: DECIMAL
NODE_37
INT: 0
NODE_38
BINARY [AND]
BINARY [>=]
IDENTIFIER: discount_percentage
INT: 0
BINARY [<=]
IDENTIFIER: discount_percentage
INT: 100
--------------------------------------------------

------------------------------------------------------------

=== Query #32 ===
SQL: SELECT      UPPER(first_name) || ' ' || LOWER(last_name) as formatted_name,     SUBSTRING(email FROM 1 FOR POSITION('@' IN email) - 1) as username,     LENGTH(bio) as bio_length FROM users WHERE email LIKE '%@example.com'

[ERROR] Parse Error
  Line 1, Column 102: Unclosed parenthesis

------------------------------------------------------------

=== Query #33 ===
SQL: SELECT      DATE_TRUNC('month', created_at) as month,     EXTRACT(YEAR FROM created_at) as year,     AGE(NOW(), created_at) as account_age,     created_at + INTERVAL '30 days' as trial_end FROM users WHERE created_at >= '2024-01-01'::DATE

Parse Statistics:
  Parse Time:          4 us
  Node Count:         14 nodes
  Tree Depth:          4 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
SELECT LIST
FUNCTION: DATE_TRUNC (schema: month)
STRING: ''month''
IDENTIFIER: created_at
FUNCTION: EXTRACT (schema: year)
IDENTIFIER: YEAR
COLUMN: created_at
FUNCTION: AGE (schema: account_age)
FUNCTION: NOW
IDENTIFIER: created_at
BINARY [+]
COLUMN: created_at
COLUMN: INTERVAL
--------------------------------------------------

------------------------------------------------------------

=== Query #34 ===
SQL: SELECT      product_name,     price,     ROUND(price * 0.9, 2) as discounted_price,     CEIL(stock / 10.0) as boxes_needed,     FLOOR(LOG(price)) as price_magnitude FROM products WHERE MOD(id, 2) = 0

Parse Statistics:
  Parse Time:          4 us
  Node Count:         24 nodes
  Tree Depth:          5 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
SELECT LIST
COLUMN: product_name
COLUMN: price
FUNCTION: ROUND (schema: discounted_price)
BINARY [*]
IDENTIFIER: price
INT: 0.9
INT: 2
FUNCTION: CEIL (schema: boxes_needed)
BINARY [/]
IDENTIFIER: stock
INT: 10.0
FUNCTION: FLOOR (schema: price_magnitude)
FUNCTION: LOG
IDENTIFIER: price
FROM
TABLE: products
WHERE
BINARY [=]
FUNCTION: MOD
IDENTIFIER: id
INT: 2
INT: 0
--------------------------------------------------

------------------------------------------------------------

=== Query #35 ===
SQL: SELECT name, email FROM customers UNION SELECT name, email FROM suppliers

Parse Statistics:
  Parse Time:          2 us
  Node Count:         13 nodes
  Tree Depth:          4 levels

Abstract Syntax Tree:
--------------------------------------------------
UNION: UNION
SELECT
SELECT LIST
COLUMN: name
COLUMN: email
FROM
TABLE: customers
SELECT
SELECT LIST
COLUMN: name
COLUMN: email
FROM
TABLE: suppliers
--------------------------------------------------

------------------------------------------------------------

=== Query #36 ===
SQL: SELECT product_id FROM orders_2023 INTERSECT SELECT product_id FROM orders_2024

Parse Statistics:
  Parse Time:          1 us
  Node Count:         11 nodes
  Tree Depth:          4 levels

Abstract Syntax Tree:
--------------------------------------------------
INTERSECT: INTERSECT
SELECT
SELECT LIST
COLUMN: product_id
FROM
TABLE: orders_2023
SELECT
SELECT LIST
COLUMN: product_id
FROM
TABLE: orders_2024
--------------------------------------------------

------------------------------------------------------------

=== Query #37 ===
SQL: SELECT id FROM all_products EXCEPT SELECT product_id FROM discontinued_products

Parse Statistics:
  Parse Time:          1 us
  Node Count:         11 nodes
  Tree Depth:          4 levels

Abstract Syntax Tree:
--------------------------------------------------
EXCEPT: EXCEPT
SELECT
SELECT LIST
COLUMN: id
FROM
TABLE: all_products
SELECT
SELECT LIST
COLUMN: product_id
FROM
TABLE: discontinued_products
--------------------------------------------------

------------------------------------------------------------

=== Query #38 ===
SQL: WITH monthly_sales AS (     SELECT          DATE_TRUNC('month', o.order_date) as month,         p.category,         SUM(oi.quantity * oi.unit_price) as revenue,         COUNT(DISTINCT o.id) as order_count,         COUNT(DISTINCT o.customer_id) as customer_count     FROM orders o     JOIN order_items oi ON o.id = oi.order_id     JOIN products p ON oi.product_id = p.id     WHERE o.order_date >= '2024-01-01'     GROUP BY DATE_TRUNC('month', o.order_date), p.category ) SELECT      month,     category,     revenue,     order_count,     customer_count,     revenue / NULLIF(order_count, 0) as avg_order_value,     LAG(revenue) OVER (PARTITION BY category ORDER BY month) as prev_month_revenue,     revenue - LAG(revenue) OVER (PARTITION BY category ORDER BY month) as month_over_month_change,     SUM(revenue) OVER (PARTITION BY category ORDER BY month ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as cumulative_revenue FROM monthly_sales ORDER BY category, month

Parse Statistics:
  Parse Time:         23 us
  Node Count:         80 nodes
  Tree Depth:          8 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
NODE_94
CTE: monthly_sales
SELECT
SELECT LIST
FUNCTION: DATE_TRUNC (schema: month)
STRING: ''month''
COLUMN: o.order_date
COLUMN: p.category
FUNCTION: SUM (schema: revenue)
BINARY [*]
COLUMN: oi.quantity
COLUMN: oi.unit_price
FUNCTION: COUNT (schema: order_count)
COLUMN: o.id
FUNCTION: COUNT (schema: customer_count)
COLUMN: o.customer_id
FROM
TABLE: orders (schema: o)
JOIN: JOIN
TABLE: order_items (schema: oi)
BINARY [=]
COLUMN: o.id
COLUMN: oi.order_id
JOIN: JOIN
TABLE: products (schema: p)
BINARY [=]
COLUMN: oi.product_id
COLUMN: p.id
WHERE
BINARY [>=]
COLUMN: o.order_date
STRING: ''2024-01-01''
GROUP BY
FUNCTION: DATE_TRUNC
STRING: ''month''
COLUMN: o.order_date
COLUMN: p.category
SELECT LIST
COLUMN: month
COLUMN: category
COLUMN: revenue
COLUMN: order_count
COLUMN: customer_count
BINARY [/] (schema: avg_order_value)
COLUMN: revenue
FUNCTION: NULLIF
IDENTIFIER: order_count
INT: 0
FUNCTION: LAG (schema: prev_month_revenue)
IDENTIFIER: revenue
WINDOW
NODE_100
COLUMN: category
ORDER BY
COLUMN: month
BINARY [-] (schema: month_over_month_change)
COLUMN: revenue
FUNCTION: LAG
IDENTIFIER: revenue
WINDOW
NODE_100
COLUMN: category
ORDER BY
COLUMN: month
FUNCTION: SUM (schema: cumulative_revenue)
IDENTIFIER: revenue
WINDOW
NODE_100
COLUMN: category
ORDER BY
COLUMN: month
NODE_102: ROWS
NODE_103: UNBOUNDED (schema: PRECEDING)
NODE_103: CURRENT ROW
FROM
TABLE: monthly_sales
ORDER BY
COLUMN: category
COLUMN: month
--------------------------------------------------

------------------------------------------------------------

=== Query #39 ===
SQL: WITH cohorts AS (     SELECT          customer_id,         DATE_TRUNC('month', MIN(order_date)) as cohort_month,         DATE_TRUNC('month', order_date) as order_month,         SUM(total) as monthly_revenue     FROM orders     GROUP BY customer_id, DATE_TRUNC('month', order_date) ), cohort_sizes AS (     SELECT          cohort_month,         COUNT(DISTINCT customer_id) as cohort_size     FROM cohorts     GROUP BY cohort_month ) SELECT      c.cohort_month,     c.order_month,     EXTRACT(MONTH FROM AGE(c.order_month, c.cohort_month)) as months_since_first_purchase,     cs.cohort_size,     COUNT(DISTINCT c.customer_id) as active_customers,     ROUND(100.0 * COUNT(DISTINCT c.customer_id) / cs.cohort_size, 2) as retention_rate,     SUM(c.monthly_revenue) as cohort_revenue FROM cohorts c JOIN cohort_sizes cs ON c.cohort_month = cs.cohort_month GROUP BY c.cohort_month, c.order_month, cs.cohort_size ORDER BY c.cohort_month, c.order_month ===

Parse Statistics:
  Parse Time:         10 us
  Node Count:         35 nodes
  Tree Depth:          8 levels

Abstract Syntax Tree:
--------------------------------------------------
SELECT
NODE_94
CTE: cohorts
SELECT
SELECT LIST
COLUMN: customer_id
FUNCTION: DATE_TRUNC (schema: cohort_month)
STRING: ''month''
FUNCTION: MIN
IDENTIFIER: order_date
FUNCTION: DATE_TRUNC (schema: order_month)
STRING: ''month''
IDENTIFIER: order_date
FUNCTION: SUM (schema: monthly_revenue)
IDENTIFIER: total
FROM
TABLE: orders
GROUP BY
COLUMN: customer_id
FUNCTION: DATE_TRUNC
STRING: ''month''
IDENTIFIER: order_date
CTE: cohort_sizes
SELECT
SELECT LIST
COLUMN: cohort_month
FUNCTION: COUNT (schema: cohort_size)
IDENTIFIER: customer_id
FROM
TABLE: cohorts
GROUP BY
COLUMN: cohort_month
SELECT LIST
COLUMN: c.cohort_month
COLUMN: c.order_month
--------------------------------------------------

============================================================
                          SUMMARY
============================================================
Total queries:         39
Successful:            38
Failed:                 1
Failed queries:    32
============================================================
